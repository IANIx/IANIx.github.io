<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flutter项目实战</title>
    <link href="/2020/08/31/Flutter%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <url>/2020/08/31/Flutter%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="APP目录结构"><a href="#APP目录结构" class="headerlink" title="APP目录结构"></a>APP目录结构</h1><h3 id="lib代码目录"><a href="#lib代码目录" class="headerlink" title="lib代码目录"></a>lib代码目录</h3><p>lib下存放的是Dart语言编写的代码，这里是核心代码。不管是Android平台，还是ios平台，安装配置好环境，可以把dart代码运行到对应的设备或模拟器上面。就是运行的<code>lib</code>目录下的<code>main.dart</code>这个文件。</p><p>目前lib下一级目录分别有common(公共)，constant(常量配置文件)，network(网络请求工具)，pages(页面), util(工具)。后面还可以继续补充(cache,db等等)</p><p><img src="image_1.png" alt="图片 1"></p><ul><li><p>common下有bean(公用的数据模型，如common_response等)，blocs(公用的状态状态管理)，event(公用的事件)，widget(公用的UI组件)。</p></li><li><p>constant下放置一些常量文件，如color_constant，image_constant，router_constant。</p></li><li><p>network下配置了网络工具类，目前配置了基础的http_request，用于一般接口请求，后续可以根据业务需求添加。</p></li><li><p>pages下根据业务模块分为application，find，home，mine。日常的页面开发都在这个文件下。</p></li><li><p>util下目前有dateTime_util(时间戳工具)，encryption_util(加解密工具)，log_util(日志工具)。待补充（toast等）</p><p><img src="image_2.png" alt="图片 2"></p></li></ul><p>在各模块的结构中，以home为例，分别有bean, bloc, event, request, state, widgets。</p><p>这里的所有文件应该是在该模块内实现，不与其他模块耦合，仅供模块内调用。</p><p><img src="image_3.png" alt="图片 3"></p><h3 id="资源目录"><a href="#资源目录" class="headerlink" title="资源目录"></a>资源目录</h3><p>在<code>assets</code>下可以存放image、font、json、xml等各种资源，在<code>pubspec.ymal</code>中声明即可使用。</p><p>Image目前有配置2.0x和3.0x。</p><p><img src="image_4.png" alt="图片 4"></p><h3 id="pubspec-yaml文件"><a href="#pubspec-yaml文件" class="headerlink" title="pubspec.yaml文件"></a>pubspec.yaml文件</h3><p>这里主要是配置项目依赖项，比如远程<code>pub</code>库，或者本地的一些资源。</p><p><img src="image_5.png" alt="图片 5"></p><h1 id="实战开发"><a href="#实战开发" class="headerlink" title="实战开发"></a>实战开发</h1><p>项目的基础配置已经配置完毕，那如何在日常开发中使用呢？</p><h3 id="资源使用"><a href="#资源使用" class="headerlink" title="资源使用"></a>资源使用</h3><p>以图片为例，将要使用的图片资源分别放入assets/images、2.0x、3.0x下，因为在<code>pubspec</code>已经引入这三个文件，所以不用再重复引入。接下来在<code>image_constant</code>中添加常量文件名称。</p><p><img src="image_6.png" alt="图片 6"></p><p>最后在使用的文件中导入头文件，就可以直接获取图片</p><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:jqzsy_flutter/constant/image_constant.dart&#x27;</span>;Image.asset(JQZImageAssets.tabbarHomeActiveIcon)</code></pre><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>在项目开发中，必不可少的就是与后端交互，后端返回的response大多是jsonString，如果直接转为Map使用也很不方便。在json转model，model转json中dart有内置的json解码器，但缺点是必须要手动解码，这样在手动编写时很容易逻辑出错从而导致程序抛出异常。所以在大型项目中一般选择自动序列化方式，可以避免人为出错，从而提高开发效率。</p><p><code>Json_annotation</code>和<code>json_serializable</code>为Google官方提供的优秀pub库，<code>build_runner</code>则可以自动生成代码。</p><p>使用方式很简单：</p><ol><li>添加自己的业务模型，添加完毕后该class用<code>@JsonSerializable()</code>标识。</li><li>手动输入“part ‘xxx.g.dart’”（注意，这里的xxx要与模型文件名称一致）。</li><li>在项目根目录下运行<code>flutter pub run build_runner build</code>命令，此时项目下会有新增的.g文件。</li><li>添加序列化和反序列化代码。</li></ol><p><img src="image_7.png" alt="图片 7"></p><p><img src="image_8.png" alt="图片 8"></p><h3 id="状态管理-BLoC"><a href="#状态管理-BLoC" class="headerlink" title="状态管理-BLoC"></a>状态管理-BLoC</h3><h4 id="为什么需要状态管理？"><a href="#为什么需要状态管理？" class="headerlink" title="为什么需要状态管理？"></a>为什么需要状态管理？</h4><p>在我们一开始构建应用的时候，也许很简单。我们有一些状态，直接把他们映射成视图就可以了。这种简单应用可能并不需要状态管理。</p><p><img src="image_9.png" alt="图片 9"></p><p>但是随着功能的增加，你的应用程序将会有几十个甚至上百个状态。这个时候你的应用应该会是这样。</p><p><img src="image_10.png" alt="图片 10"></p><p>在应用越来越复杂的时候，我们的状态变得很难维护。而且涉及到多个页面共享状态时，你就需要同步多个状态。</p><p>所以需要一个状态管理框架帮我来理清关系，明确职责。</p><h4 id="状态管理框架有哪些？"><a href="#状态管理框架有哪些？" class="headerlink" title="状态管理框架有哪些？"></a>状态管理框架有哪些？</h4><p>Flutter中有很多优秀的状态管理框架，如<strong>Redux</strong>, <strong>Provide</strong>, <strong>Provider</strong>, <strong>Bloc</strong>。</p><p>Bloc官方地址：<a href="https://bloclibrary.dev/">https://bloclibrary.dev/</a></p><h4 id="选择BloC的原因？"><a href="#选择BloC的原因？" class="headerlink" title="选择BloC的原因？"></a>选择BloC的原因？</h4><p>状态管理的本质就是为了让界面与业务分离。界面根据<strong>state</strong>来显示，操作事件时发出<strong>Action</strong>或<strong>Event</strong>,业务交给<strong>bloc</strong>处理。</p><p>Bloc其实类似mvvm中的viewModel,负责所有业务的处理。</p><p><strong>flutter_bloc+bloc</strong>库内部封装了<em>stream</em>和<em>RxDart</em>来实现BLoC，所以直接使用这个库就可以了。</p><p>Bloc可以方便的把样式与业务逻辑区分开，从而使开发更便捷，可重用性更好，测试也更加方便。</p><p><img src="image_11.png" alt="图片 11"></p><h4 id="如何使用BLoC"><a href="#如何使用BLoC" class="headerlink" title="如何使用BLoC?"></a>如何使用BLoC?</h4><p>从官方的计数器来简单实例如何使用bloc。</p><p>首先创建计数器Event,在CounterEvent中标识事件枚举类型。</p><p><img src="image_12.png" alt="图片 12"></p><p>其次添加bloc文件，创建Counter继承Bloc&lt;CounterEvent, int&gt;，</p><p>必须实现initialState和mapEventToState方法。并在mapEventToState中做好事件对应的逻辑处理。</p><p>因为计数器较为简单，只用返回基本int类型，所以不用创建state了。</p><p><img src="image_13.png" alt="图片 13"></p><p>最后在UI层使用。</p><p>使用BlocProvider在需要该Bloc的Widget Tree上进行包裹，这里直接放到了整个页面上，可以根据需要放到适当的Widget Tree层级上，同时这里的BlocProvider也自动处理了CounterBloc的关闭操作，所以我们不必使用一个StatefulWidget。</p><p>然后就是在页面中使用BlocBuilder，我们通过扩展函数的形式或者使用BlocProvider.of(context)获取CounterBloc，然后在builder函数中，使用当前的State对象值count，并通过counterBloc对象进行事件Event变化的操作。</p><p><img src="image_15.png" alt="图片 15"></p><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>http请求在google官方Dio库的基础上进行了二次封装，支持GET与POST两种方式。</p><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">request method</span></span>  <span class="hljs-comment">//url 请求链接</span>  <span class="hljs-comment">//parameters 请求参数</span>  <span class="hljs-comment">//method 请求方式</span>  <span class="hljs-comment">//onSuccess 成功回调</span>  <span class="hljs-comment">//onError 失败回调</span>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">bool</span>&gt; request&lt;T&gt;(<span class="hljs-built_in">String</span> url,      &#123;parameters,      headers,      method,      <span class="hljs-built_in">Function</span>(T t) onSuccess,      <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">String</span> error) onError&#125;) <span class="hljs-keyword">async</span> &#123;    parameters = parameters ?? &#123;&#125;;    method = method ?? <span class="hljs-string">&#x27;GET&#x27;</span>;    <span class="hljs-comment">/// <span class="markdown">请求处理</span></span>    parameters.forEach((key, value) &#123;      <span class="hljs-keyword">if</span> (url.indexOf(key) != <span class="hljs-number">-1</span>) &#123;        url = url.replaceAll(<span class="hljs-string">&#x27;:<span class="hljs-subst">$key</span>&#x27;</span>, value.toString());      &#125;    &#125;);    Dio dio = <span class="hljs-keyword">await</span> createInstance(url);    <span class="hljs-comment">//请求结果</span>    <span class="hljs-keyword">var</span> result;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; header = &#123;&#125;;      <span class="hljs-keyword">if</span> (headers != <span class="hljs-keyword">null</span>) &#123;        header.addAll(headers);      &#125;      header.addAll(_configTestHeaders());      Response response = <span class="hljs-keyword">await</span> dio.request(url,          data: parameters,          options: <span class="hljs-keyword">new</span> Options(method: method, headers: header));      JQZLogUtil.e(          <span class="hljs-string">&#x27;method - <span class="hljs-subst">$&#123;method&#125;</span> \n url - <span class="hljs-subst">$&#123;url&#125;</span> \n headers - <span class="hljs-subst">$&#123;headers&#125;</span> \n parmars - <span class="hljs-subst">$&#123;parameters&#125;</span> \n response - <span class="hljs-subst">$&#123;response.toString()&#125;</span>&#x27;</span>,          tag: JQZLogUtil.TAG_NETWORK);      result = jsonDecode(response.data);      <span class="hljs-keyword">if</span> (response.statusCode == <span class="hljs-number">200</span>) &#123;        <span class="hljs-keyword">if</span> (onSuccess != <span class="hljs-keyword">null</span>) &#123;          onSuccess(result);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&#x27;statusCode:<span class="hljs-subst">$&#123;response.statusCode&#125;</span>&#x27;</span>);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">on</span> DioError <span class="hljs-keyword">catch</span> (e) &#123;      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请求出错：&#x27;</span> + e.toString());      onError(e.toString());      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;  &#125;        <span class="hljs-comment">/// <span class="markdown">创建 dio 实例对象</span></span>  <span class="hljs-keyword">static</span> Future&lt;Dio&gt; createInstance(<span class="hljs-built_in">String</span> url) <span class="hljs-keyword">async</span> &#123;    <span class="hljs-keyword">if</span> (dio == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">/// <span class="markdown">全局属性：请求前缀、连接超时时间、响应超时时间</span></span>      <span class="hljs-keyword">var</span> options = BaseOptions(        connectTimeout: <span class="hljs-number">15000</span>,        receiveTimeout: <span class="hljs-number">15000</span>,        responseType: ResponseType.plain,        headers: _configCommonHeaders(url),        contentType: <span class="hljs-string">&#x27;application/json; charset=utf-8&#x27;</span>,        validateStatus: (status) &#123;          <span class="hljs-comment">// 不使用http状态码判断状态，使用AdapterInterceptor来处理（适用于标准REST风格）</span>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;,        baseUrl: <span class="hljs-string">&quot;http://xxxx&quot;</span>,      );      dio = <span class="hljs-keyword">new</span> Dio(options);    &#125;    <span class="hljs-keyword">return</span> dio;  &#125;</code></pre><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">http request methods</span></span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> GET = <span class="hljs-string">&#x27;get&#x27;</span>;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> POST = <span class="hljs-string">&#x27;post&#x27;</span>;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> PUT = <span class="hljs-string">&#x27;put&#x27;</span>;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> PATCH = <span class="hljs-string">&#x27;patch&#x27;</span>;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> DELETE = <span class="hljs-string">&#x27;delete&#x27;</span>;  <span class="hljs-comment">///<span class="markdown">Get请求</span></span>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">bool</span>&gt; <span class="hljs-keyword">get</span>&lt;T&gt;(    <span class="hljs-built_in">String</span> url, &#123;    parameters,    headers,    <span class="hljs-built_in">Function</span>(T t) onSuccess,    <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">String</span> error) onError,  &#125;) <span class="hljs-keyword">async</span> &#123;    <span class="hljs-keyword">return</span> JQZHttpRequest.request(url,        parameters: parameters,        headers: headers,        method: GET,        onSuccess: onSuccess,        onError: onError);  &#125;  <span class="hljs-comment">///<span class="markdown">Post请求</span></span>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">bool</span>&gt; post&lt;T&gt;(    <span class="hljs-built_in">String</span> url, &#123;    parameters,    headers,    <span class="hljs-built_in">Function</span>(T t) onSuccess,    <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">String</span> error) onError,  &#125;) <span class="hljs-keyword">async</span> &#123;    <span class="hljs-keyword">return</span> JQZHttpRequest.request(      url,      parameters: parameters,      headers: headers,      method: POST,      onSuccess: onSuccess,      onError: onError,    );  &#125;</code></pre><p>使用方式很简单，传递url与parameters,并且在success与error回调中处理逻辑。</p><h1 id="常见三方插件"><a href="#常见三方插件" class="headerlink" title="常见三方插件"></a>常见三方插件</h1><p># 网络请求框架</p><p>dio: ^3.0.7</p><p># sp</p><p>shared_preferences: ^0.5.6</p><p># 微信sdk</p><p>fluwx: ^1.2.1+1</p><p># swiper 轮播插件</p><p>flutter_swiper: ^1.1.6</p><p># 个推 sdk</p><p>getuiflut: ^0.1.6</p><p># Flutter 调试工具</p><p>flutter_flipperkit: ^0.0.21</p><p># flipper sqflite调试</p><p>flipperkit_sqflite_driver: 0.0.2</p><p># json生成</p><p>json_annotation: ^2.2.0</p><p># 下载器</p><p>flutter_downloader: 1.1.7</p><p># 获取系统路径</p><p>path_provider: ^1.3.0</p><p># 系统权限管理</p><p>permission_handler: ^4.3.0</p><p># 通知权限管理</p><p>notification_permissions: ^0.4.4</p><p># webview</p><p>flutter_webview_plugin: ^0.3.4</p><p># 唤起其他app</p><p>url_launcher: ^5.0.2</p><p># growingio 统计</p><p>flutter_growingio_track:</p><p>path: plugins/flutter_growingio_track-2.6.4</p><p># 设备信息</p><p>device_info: ^0.4.0</p><p># 生成uuid</p><p>uuid: 2.0.2</p><p># 事件传递</p><p>event_bus: ^1.1.0</p><p># loading 样式组件</p><p>flutter_spinkit: ^4.0.0</p><p># qq sdk</p><p>flutter_qq: ^0.0.5</p><p># 代码包信息</p><p>package_info: ^0.4.0+6</p><p># 状态管理</p><p>provider: ^3.0.0+1</p><p># 选择器</p><p>flutter_picker: ^1.0.13</p><p># 图片裁剪</p><p>image_cropper: ^1.0.2</p><p># 图片选择</p><p>image_picker: ^0.6.1+2</p><p># 路由框架</p><p>fluro: ^1.5.1</p><p># pdf浏览器</p><p>flutter_full_pdf_viewer: ^1.0.4</p><p># 避免输入框被键盘遮挡</p><p>keyboard_avoider: ^0.1.2</p><p># 屏幕适配 <a href="https://github.com/OpenFlutter/flutter_screenutil">https://github.com/OpenFlutter/flutter_screenutil</a></p><p>flutter_screenutil: ^1.1.0</p><p># Toast插件 <a href="https://github.com/OpenFlutter/flutter_oktoast">https://github.com/OpenFlutter/flutter_oktoast</a></p><p>oktoast: ^2.2.0</p><p># 日期选择器</p><p>flutter_cupertino_date_picker: ^1.0.12</p><p># 小红点插件 badge <a href="https://pub.dev/packages/flutter_badge">https://pub.dev/packages/flutter_badge</a></p><p>flutter_badge: ^0.0.1</p><p># 自定义上拉加载和下拉刷新效果 flutter_easyrefresh 前提：必须是一个ListView</p><p>flutter_easyrefresh: ^1.2.7</p><p># 音频播放插件: <a href="https://pub.flutter-io.cn/packages/audioplayers">https://pub.flutter-io.cn/packages/audioplayers</a></p><p>audioplayers: ^0.13.2</p><p># 录音: <a href="https://pub.flutter-io.cn/packages/audio_recorder">https://pub.flutter-io.cn/packages/audio_recorder</a></p><p>audio_recorder:</p><p>path: plugins/audio_recorder-1.0.1</p><p># 瀑布流插件 <a href="https://github.com/letsar/flutter_staggered_grid_view">https://github.com/letsar/flutter_staggered_grid_view</a></p><p>flutter_staggered_grid_view: ^0.3.0</p><p># 图片浏览器: <a href="https://pub.flutter-io.cn/packages/photo_view">https://pub.flutter-io.cn/packages/photo_view</a></p><p>photo_view: ^0.9.0</p><p># 数据加解密</p><p>encrypt: 3.3.1</p><p># 网络状态插件connectivity: ^0.4.8+2</p><p>connectivity: ^0.4.8+2</p><p># 腾讯im</p><p>dim:</p><p>path: plugins/dim</p><p># sql</p><p>sqflite: ^1.1.7+1</p><p># 富文本输入</p><p>extended_text_field: 0.4.9</p><p># 富文本展示</p><p>extended_text: ^0.6.6</p><p># 振动</p><p>vibration: 1.2.2</p><p># 弹出气泡</p><p>w_popup_menu: ^0.2.5</p><p># 高德-仅地图</p><p>amap_map_fluttify:</p><p>path: plugins/amap_map_fluttify-develop3</p><p># amap_map_fluttify: 0.18.2+c038d50</p><p># 高德-仅定位</p><p>amap_location_fluttify: 0.8.11+481e45c</p><p># 图片缓存</p><p>cached_network_image: 2.0.0-rc.1</p><p># iOS 内购</p><p>flutter_inapp_purchase: ^2.1.0</p><p># 获取设备id: <a href="https://pub.flutter-io.cn/packages/unique_ids">https://pub.flutter-io.cn/packages/unique_ids</a></p><p>unique_ids: 1.0.10</p><p># 获取设备user_agent</p><p>flutter_user_agent:</p><p>path: plugins/flutter_user_agent-1.2.1</p><p># 颜色插件</p><p>color: 2.1.1</p><p># 消息上下轮播(跑马灯)</p><p>marquee: 1.3.1</p><p># 为SVG路径和代码生成创建一个纯Dart解析库</p><p>path_parsing: 0.1.4</p><p># 异常捕获及日志打印</p><p># <a href="https://pub.flutter-io.cn/packages/sentry">https://pub.flutter-io.cn/packages/sentry</a></p><p>sentry: 3.0.1</p><p># 基于dio的网络请求日志</p><p>dio_log: ^1.3.3</p><p># 支付代码测试</p><p>iap_pay:</p><p>git:</p><p> url: <a href="https://gitee.com/Steven_Hu/iap_pay.git">https://gitee.com/Steven_Hu/iap_pay.git</a></p><p> ref: master</p><h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><ol><li><p>库、包、目录、源文件名字规则:小写加下划线[_]<br> <code>library peg_parser.source_scanner;</code><br> <code>import &#39;file_system.dart&#39;;</code></p></li><li><p>类成员，顶级定义，变量，参数和命名参数应该大写除第一个单词之外的每个单词的第一个字母，并且不使用分隔符</p><pre><code class="hljs dart"><span class="hljs-keyword">var</span> item ;HttpRequest httpRequest ;<span class="hljs-keyword">void</span> align （<span class="hljs-built_in">bool</span> clearItems ）&#123; <span class="hljs-comment">// ... &#125;</span></code></pre></li><li><p>类名，枚举等应该首字母大写，并包含固定前缀，如JQZ</p></li></ol><p><code>class JQZBusinessPlugin &#123;&#125;</code></p><p><code>class JQZHomePage extends StatefulWidget &#123;&#125;</code></p><ol start="4"><li><p>代码经常使用格式化工具，VCCode快捷键 S+C+F</p></li><li><p>业务与页面分离，业务代码最好都放置在bloc中处理，少量业务的页面可以使用setState更新。Page中组件拆分，如</p></li></ol><pre><code class="hljs dart">Widget build(BuildContext context) &#123;  <span class="hljs-keyword">return</span> Scaffold(   body: SingleChildScrollView(​    child: _buidContent(),   ),  ); &#125; Widget _buidContent() &#123;  <span class="hljs-keyword">return</span> Column(   children: &lt;Widget&gt;[_buildTopWidget(), _buildNewsWidget()],  ); &#125;</code></pre><h1 id="混合开发"><a href="#混合开发" class="headerlink" title="混合开发"></a>混合开发</h1><p>在搭建混合工程，最重要的就是以下两点：</p><p>对原生工程无侵入：原生工程可以增加组件的依赖，但不能修改主工程的配置，更不能让原生工程对环境产生新的依赖。</p><p>方便调试：不管是原生工程开发，调试新接入的模块（比如 Flutter），还是模块开发调试原生工程，都应该支持断点调试。</p><h3 id="FlutterBoost"><a href="#FlutterBoost" class="headerlink" title="FlutterBoost"></a>FlutterBoost</h3><p>新一代Flutter-Native混合解决方案。 FlutterBoost是一个Flutter插件，它可以轻松地为现有原生应用程序提供Flutter混合集成方案。FlutterBoost的理念是将Flutter像Webview那样来使用。在现有应用程序中同时管理Native页面和Flutter页面并非易事。 FlutterBoost帮你处理页面的映射和跳转，你只需关心页面的名字和参数即可（通常可以是URL）</p><h3 id="如何集成flutterBoost"><a href="#如何集成flutterBoost" class="headerlink" title="如何集成flutterBoost"></a>如何集成flutterBoost</h3><p>首先按照官方文档将原生工程配置flutter组件依赖，以iOS为例。</p><p>用cocopods配置对三方库的管理，然后在podfile中配置flutter地址。请注意，flutter主工程要与native工程在同一目录下。</p><pre><code class="hljs objective-c"># Uncomment the next line to define a global platform for your projectplatform :ios, &#39;10.0&#39;target &#39;xxx&#39; do  # Comment the next line if you don&#39;t want to use dynamic frameworks  use_frameworks!   flutter_application_path &#x3D; &quot;..&#x2F;app&#x2F;&quot;   load File.join(flutter_application_path,&#39;.ios&#39;,&#39;Flutter&#39;,&#39;podhelper.rb&#39;)   install_all_flutter_pods(flutter_application_path)end</code></pre><p>配置完后直接执行<code>pod install</code>。</p><p><img src="podinstall_image.png" alt="podinstall_image"></p><p><code>pod install</code>结果显示添加的插件都已下载完毕。</p><p>这样混合开发环境就已经配置完成了。</p><h3 id="Flutter与iOS页面跳转"><a href="#Flutter与iOS页面跳转" class="headerlink" title="Flutter与iOS页面跳转"></a>Flutter与iOS页面跳转</h3><p>在配置好flutterBoost之后，在iOS工程创建一个flutterRouter类，然后在delegate中做flutter初始化的工作。</p><pre><code class="hljs objective-c">JQZFlutterRouter * router &#x3D; [JQZFlutterRouter sharedRouter];   [[FlutterBoostPlugin sharedInstance] startFlutterWithPlatform:router onStart:^(FlutterEngine *engine) &#123;       [JQZFlutterRouter sharedRouter].engine &#x3D; engine;&#125;];</code></pre><p>JQZFlutterRouter，内部实现打开native页面的路由代码。</p><pre><code class="hljs objective-c">@implementation JQZFlutterRouter+ (instancetype)sharedRouter&#123;    static JQZFlutterRouter *_instance &#x3D; nil;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        _instance &#x3D; [[JQZFlutterRouter alloc] init];        [GeneratedPluginRegistrant new]; &#x2F;&#x2F;&#x2F; 空方法占位，防止flutter初始化plugin无法注册    &#125;);    return _instance;&#125;- (void)setEngine:(FlutterEngine *)engine &#123;    _engine &#x3D; engine;    [[JQZFlutterBusinessPlugin new] setupPluginsWithMessenger:engine.binaryMessenger];    [[JQZFlutterMessageStreamHander new] setupMessageHanderWithMessenger:engine.binaryMessenger];&#125;&#x2F;&#x2F;&#x2F; 跳转flutter页面- (void)open:(NSString *)name urlParams:(NSDictionary *)params &#123;    [FlutterBoostPlugin open:name                   urlParams:params                        exts:@&#123;@&quot;animated&quot;:@(YES)&#125;              onPageFinished:^(NSDictionary *result) &#123;        NSLog(@&quot;Opened %@ page%@&quot;, name, result);    &#125; completion:^(BOOL finish) &#123;    &#125;];&#125;&#x2F;&#x2F;&#x2F; Native与flutter相互跳转- (void)open:(NSString *)name urlParams:(NSDictionary *)params exts:(NSDictionary *)exts completion:(void (^)(BOOL))completion &#123;    if ([name hasPrefix:@&quot;flutterbus:&quot;]) &#123;&#x2F;&#x2F;打开原生页面        [JQZPageJumpHander open:name urlParams:params exts:exts completion:completion];        return;    &#125;        BOOL animated &#x3D; [exts[@&quot;animated&quot;] boolValue];    JQZFlutterViewController *vc &#x3D; JQZFlutterViewController.new;    [vc setName:name params:params];    [self.navigationController pushViewController:vc animated:animated];    if(completion) completion(YES);&#125;</code></pre><p>这样就实现flutter与iOS原生页面相互跳转的实现。</p><p>示例：</p><p><strong>iOS打开flutter页面</strong>：</p><pre><code class="hljs objective-c">[[JQZFlutterRouter sharedRouter] open:@&quot;setting&quot; urlParams:nil];</code></pre><p><strong>Flutter打开iOS页面</strong>：</p><pre><code class="hljs dart">FlutterBoost.singleton.open(   <span class="hljs-string">&quot;flutterbus://homeEditSecond&quot;</span>,  );</code></pre><h3 id="Flutter与iOS事件传递"><a href="#Flutter与iOS事件传递" class="headerlink" title="Flutter与iOS事件传递"></a>Flutter与iOS事件传递</h3><h4 id="Platform-Channel"><a href="#Platform-Channel" class="headerlink" title="Platform Channel"></a>Platform Channel</h4><p>每个 Channel 都有一个独一无二的名字，Channel 之间通过 name 区分彼此。</p><p>Channel 使用 codec 消息编解码器，支持从基础数据到二进制格式数据的转换、解析。</p><p>Channel 有三种类型，分别是：<br> <code>BasicMessageChannel</code>：用于传递基本数据<br> <code>MethodChannel</code>： 用于传递方法调用，Flutter 侧调用 native 侧的功能，并获取处理结果。<br> <code>EventChannel</code>：用于向 Flutter 侧传递事件，native 侧主动发消息给 Flutter。<br> 这三种类型比较相似，因为它们都是传递数据，实现方式也比较类似。</p><p> flutterboost有提供的便捷使用方式：</p><p><img src="image_16.png" alt="图片 16"></p><p>但是flutterboost使用的通道名称为固定的flutter_boost，如果要自定义通道名称还是使用官方方法。</p><h4 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h4><p>在iOS工程中，新建一个JQZFlutterBusinessPlugin用于配置接收事件的处理。</p><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">JQZFlutterBusinessPlugin</span></span><span class="hljs-comment">///注册插件</span>- (<span class="hljs-keyword">void</span>)setupPluginsWithMessenger:(<span class="hljs-built_in">NSObject</span>&lt;FlutterBinaryMessenger&gt;*)messenger &#123;    <span class="hljs-comment">// 用于Flutter 调用 Native</span>    <span class="hljs-comment">// 这个channelname必须与Native里接收的一致 FlutterBinaryMessenger</span>    FlutterMethodChannel *methodChannel = [FlutterMethodChannel methodChannelWithName:methodChannelName binaryMessenger:messenger];    [methodChannel setMethodCallHandler:^(FlutterMethodCall * _Nonnull call, FlutterResult  _Nonnull result) &#123;        <span class="hljs-keyword">if</span> ([call.method isEqualToString:<span class="hljs-string">@&quot;getUserInfo&quot;</span>]) &#123; <span class="hljs-comment">///获取用户信息</span>            [<span class="hljs-keyword">self</span> handleUserInfoMethodCall:call result:result];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([call.method isEqualToString:<span class="hljs-string">@&quot;getNativeTheme&quot;</span>]) &#123; <span class="hljs-comment">///获取原生主题</span>            [<span class="hljs-keyword">self</span> handleThemeMethodCall:call result:result];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([call.method isEqualToString:<span class="hljs-string">@&quot;getRequestHeader&quot;</span>]) &#123; <span class="hljs-comment">///获取请求头</span>            [<span class="hljs-keyword">self</span> handleRequestHeaderMethodCall:call result:result];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([call.method isEqualToString:<span class="hljs-string">@&quot;getMainUrl&quot;</span>]) &#123; <span class="hljs-comment">///获取请求头</span>            [<span class="hljs-keyword">self</span> handleMainUrlMethodCall:call result:result];        &#125;    &#125;];&#125;- (<span class="hljs-keyword">void</span>)handleUserInfoMethodCall:(FlutterMethodCall *)call result:(FlutterResult)result &#123;    <span class="hljs-keyword">if</span> (result) &#123;        <span class="hljs-keyword">if</span>([UserDefaultsFactory getLoginInfo])&#123;            result([UserDefaultsFactory getLoginInfo]);        &#125;    &#125;&#125;</code></pre><p>在flutter工程中，同样也配置一样的busninessPlugin用于发起事件。</p><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JQZBusinessPlugin</span> </span>&#123;  Future&lt;<span class="hljs-built_in">Map</span>&gt; getUserInfo() <span class="hljs-keyword">async</span> &#123;    <span class="hljs-built_in">Map</span> result;    <span class="hljs-keyword">try</span> &#123;      result = <span class="hljs-keyword">await</span> platform.invokeMethod(<span class="hljs-string">&quot;getUserInfo&quot;</span>);    &#125; <span class="hljs-keyword">on</span> PlatformException <span class="hljs-keyword">catch</span> (e) &#123;      result = &#123;&#125;;    &#125;    JQZLogUtil.e(<span class="hljs-string">&quot;getUserInfo result - <span class="hljs-subst">$&#123;result&#125;</span>&quot;</span>, tag: <span class="hljs-string">&#x27;[JQZBusinessPlugin]&#x27;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt;.from(result);  &#125;  Future&lt;<span class="hljs-built_in">Map</span>&gt; getNativeTheme() <span class="hljs-keyword">async</span> &#123;    <span class="hljs-built_in">Map</span> result;    <span class="hljs-keyword">try</span> &#123;      result = <span class="hljs-keyword">await</span> platform.invokeMethod(<span class="hljs-string">&quot;getNativeTheme&quot;</span>);    &#125; <span class="hljs-keyword">on</span> PlatformException <span class="hljs-keyword">catch</span> (e) &#123;      result = &#123;&#125;;    &#125;    JQZLogUtil.e(<span class="hljs-string">&quot;getNativeTheme result - <span class="hljs-subst">$&#123;result&#125;</span>&quot;</span>,        tag: <span class="hljs-string">&#x27;[JQZBusinessPlugin]&#x27;</span>);    <span class="hljs-keyword">return</span> result;  &#125;&#125;</code></pre><p>主要，通道名称要保持一致。这样methodChannel就配置完成了。</p><p>使用方式：</p><pre><code class="hljs dart"><span class="hljs-built_in">String</span> userInfo = <span class="hljs-keyword">await</span> JQZBusinessPlugin().getUserInfo();</code></pre><h4 id="EventChannel"><a href="#EventChannel" class="headerlink" title="EventChannel"></a>EventChannel</h4><p>与MethodChannel类似，在iOS工程中添加一个MessageHander用于接收处理。</p><pre><code class="hljs objective-c">@implementation JQZFlutterMessageStreamHander- (instancetype)init &#123;    self &#x3D; [super init];    if (self) &#123;            &#125;    return self;&#125;- (void)setupMessageHanderWithMessenger:(NSObject&lt;FlutterBinaryMessenger&gt;*)messenger &#123;    FlutterEventChannel *eventChannel &#x3D; [FlutterEventChannel eventChannelWithName:eventChannelName binaryMessenger:messenger];    [eventChannel setStreamHandler:self];&#125;- (FlutterError* _Nullable)onListenWithArguments:(id _Nullable)arguments                                       eventSink:(FlutterEventSink)events &#123;    if (events) &#123;        events(@&quot;Native向flutter发消息&quot;);    &#125;    return nil;&#125;- (FlutterError* _Nullable)onCancelWithArguments:(id _Nullable)arguments &#123;    return nil;&#125;</code></pre><p>然后在flutter工程中配置对该channel的监听.</p><pre><code class="hljs dart"><span class="hljs-keyword">const</span> EventChannel eventChannel = <span class="hljs-keyword">const</span> EventChannel(<span class="hljs-string">&quot;jqz.flutter.io/nativeCallFlutter&quot;</span>);</code></pre><pre><code class="hljs dart">eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);</code></pre><pre><code class="hljs dart"> <span class="hljs-keyword">void</span> _onEvent(<span class="hljs-built_in">Object</span> event) &#123;​    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flutter收到Native发来消息 <span class="hljs-subst">$&#123;event&#125;</span>&quot;</span>);​    <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">is</span> <span class="hljs-built_in">Map</span>) &#123;​      <span class="hljs-built_in">String</span> name = event[<span class="hljs-string">&#x27;name&#x27;</span>];​      <span class="hljs-keyword">if</span> (native_flutter_callbakcs[name] != <span class="hljs-keyword">null</span>) &#123;​        native_flutter_callbakcs[name](event);​      &#125;​    &#125;  &#125;</code></pre><p>这样就完成iOS对flutter发消息的处理。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
